# 코틀린의 결

## 코틀린은 가변 상태를 변경하는 것보다 불변 데이터를 변환하는 쪽을 선호한다.

데이터 클래스를 사용하며 값 의미론을 제공하는 새로운 타입을 쉽게 정의할 수 있다.  
표준 라이브러를 활용하면 루프를 돌면서 가변 데이터를 메모리에서 갱신하는 것보다 불변 데이터로 이뤄진 컬렉션의 변환을 훨씬 더 쉽고 간결하게 활용할 수 있다.

## 코틀린은 동작을 명시적으로 작성하는 쪽을 더 선호한다.

예를 들어, 코틀린에는 암시적인 타입 변환이 없다.  
심지어 더 작은 데이터 타입을 더 큰 테이터 타입으로 자동으로 변환해 주지도 않는다.  
자바는 정보 손실이 없으므로 int를 long으로 암시적으로 변환해 준다.  
하지만 코틀린에서는 Int.toLong()을 명시적으로 호출해야 한다.  
명시성을 선호하는 경향은 흐름 제어에서 더 강하다.  
직접 작성한 타입에서 산술 연산이나 비교 연살을 오버로드할 수는 있지만, 쇼트서킷 연사자에 대한 오버로드는 불가능하다.  
이런 연산자를 오버로드할 수 있게 허용하면 제어 흐름이 달라질 수 있기 때문이다.

## 코틀린은 동적 바인딩보다 정적 바인딩을 더 선호한다.

코틀린은 타입 안전한, 합성적인 코딩 스타일을 장려한다.  
확장 함수는 정적으로 반인딩된다. 기본적으로 클래스는 확장될 수 없고, 메서드는 다형적이지 않다.  
여러분은 명시적으로 다형성과 상속을 활성화해야 한다. 리플렉션을 사용하고 싶으면 플랫폼별로 다른 리플렉션 라이브러리를 의존 관계에 추가해야만 한다.  
코틀린은 동적으로 코드를 분석해 프로그래머를 안내해 주고, 코드 내비게이션을 자동화하며, 프로그램을 자동으로 변환할 수 있는 코틀린 언어를 잘 아는 IDE와 함께 사용하도록 만들어졌다.

## 코틀린은 특별한 경우를 좋아하지 않는다.

자바와 달리 코틀린에는 예측할 수 없는 방식으로 작동하는 특별한 경우가 더 적다.  
원시 타입과 참조 타입 사이에 구분이 없다. 반환 시 아무 값도 돌려주지 않는 함수에 대한 void 타입도 없다.  
코틀린 함수는 값을 반환하거나 아무것도 반환하지 않거나 둘 중 하나다.
확장 함수를 사용하면 기존 타입에 새로운 연산을 추가할 수 있고, 호출하는 쪽의 코드에서는 기존 연산과 확장 함수를 구분할 수 없다.  
인라인 함수를 사용해 새로운 제어 구조를 작성할 수도 있다. 그리고 break, continue, return 문은 이런 제어 구조 내부에서도 기본 내장된 제어 구조 내부에서와 똑같이 작동한다.

## 코틀린은 마이그레이션을 쉽게 하기 위해 자신의 규칙을 깬다.

코틀린 언어에는 숙어처럼 사용하는 자바와 코틀린 코드가 동시에 존재하도록 허용하기 위한 기능이 들어있다.  
이런 기능 중 일부는 타입 검사기가 보장하는 안정성을 없애기 때문에 기존 자바 코드와 함께 사용할 때만 사용해야 한다.  
예를 들어, lateinit은 타입 시스템에 구멍을 만들기 때문에, 객체를 리플렉션을 통해 초기화하는 자바 의존 관계 주입 프레임워크는 컴파일러가 일반적으로 강제하는 캡슐화 경계를 간단히 무시하고 값을 주입할 수
있다.  
어떤 프로퍼티를 lateinit var로 선언하면 이 값을 읽기 전에 초기화할 책임이 여러분에게 있다. 컴파일러는 이런 실수를 감지할 수 없다.  